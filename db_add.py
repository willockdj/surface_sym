def db_add(in_out, db_name, csv_path, start=True, optimised=True, all=False):
    '''
    Adding the results into one coherent database, consistent with the naming
    scheme and data as generated by ase_write_full_cover.

    Parameters:

    in_out: list of tuples
        First argument in a tuple is the name of the input file used, consistent
        with naming scheme from ase_write_full_cover. Second argument in a tuple
        is the list of atoms objects, e.g.:
        [("ads_slab_16_511_127.in", read("atoms.traj@:")), ...]

    db_name: string
        Name of the ASE databse file that needs to be created. If it exists it
        will be appended
        TODO: Check for duplicates when adding new objects to db

    csv_path: string
        Absolute path to the degen_?.csv file, where ? is a number corresponding
        to the number of adsorbates on the surface. The CSV is as generated by
        ase_write_full_cover, i.e. current layout is: index, filename, fcc, hcp,
        degeneracy.
        TODO: make sure the CSV file has column names consistent with data in
        the the columns (hcp and fcc were swapped)

    start: boolean
        If True, first Atoms object of in_out[1] is written into the db
        with a state keyword "start". True by default.

    optimised: boolean
        If True, last Atoms object of in_out[1] is written into the db
        with a state keyword "optimised". True by default.

    all: boolean
        If True, all Atoms objects of in_out[1] are written into the db
        with a state keyword "intermediate" for Atoms objects in between the
        last and initial. False by default.


    '''
    import os
    from ase.io import read
    import numpy as np

    # Ensure correct input is used prior to manipulating the database
    assert type(in_out) == type([]), "The in_out must be a list"
    assert type(in_out[0])==type(()), "The in_out list must contain tuples"
    assert type(in_out[0][0]) == type(""), "The first argument in tuples in in_out must be a string"
    assert type(in_out[0][1]) == type([]), "The second argument in tuples in in_out must be a list of Atoms objects"

    # access the csv file containing information about structures
    with open(csv_path, 'r') as f:
        csv_data = [i.split(",") for i in f.readlines()]
        # remove "\n" from last argument
        csv_data = [i[:-1] + [i[-1][:-1]] for i in csv_data]

    #######################################
    from ase.db import connect
    with connect(db_name) as db:
        for i in in_out:
                # Read geometries to compare
                filename = i[0]
                # take input file name to match data from CSV
                extract_id = filename.split("/")[-1].split("_")
                fcc = extract_id[-2]
                hcp = extract_id[-1][:-3]

                # Core functionality - fcc/hcp contained in filename, so can compare to CSV data
                for j in csv_data:
                     if filename == j[1] and fcc == j[2] and hcp == j[3]:
                        original_filename = j[1]
                        index = int(j[0])
                        degen = int(j[4])
                        fcc = int(j[2])
                        hcp = int(j[3])

                # Easy mistake 
                if len(i[1]) == 1 and start and optimised:
                    raise ValueError("Only one structure provided, but both start and optimised write requested, which is it?")

                if start:
                    db.write(i[1][0], index=index, filename=original_filename, fcc=fcc, hcp=hcp,degen=degen, state="start")

                if optimised:
                    db.write(i[1][-1], index=index, filename=original_filename, fcc=fcc, hcp=hcp, degen=degen, state="optimised")

                if all:
                    for atoms in i[1][1:-1]:
                        db.write(atoms, index=index, filename=original_filename, fcc=fcc, hcp=hcp, degen=degen, state="intermediate")
